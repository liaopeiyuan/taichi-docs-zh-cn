# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2020, Taichi Developers
# This file is distributed under the same license as the taichi package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2020.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: taichi 0.6.10\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2020-06-14 12:50+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.8.0\n"

#: ../../export_results.rst:2
msgid "Export your results"
msgstr ""

#: ../../export_results.rst:3
msgid ""
"Taichi has functions that help you **export visual results to images or "
"videos**. This tutorial demonstrates how to use them step by step."
msgstr ""

#: ../../export_results.rst:6
msgid "Export images"
msgstr ""

#: ../../export_results.rst:8
msgid "There are two ways to export visual results of your program to images."
msgstr ""

#: ../../export_results.rst:9
msgid "The first and easier way is to make use of ``ti.GUI``."
msgstr ""

#: ../../export_results.rst:10
msgid "The second way is to call some Taichi functions such as ``ti.imwrite``."
msgstr ""

#: ../../export_results.rst:13
msgid "Export images using ``ti.GUI.show``"
msgstr ""

#: ../../export_results.rst:15
msgid ""
"``ti.GUI.show(filename)`` can not only display the GUI canvas on your "
"screen, but also save the image to your specified ``filename``."
msgstr ""

#: ../../export_results.rst:16
msgid ""
"Note that the format of the image is fully determined by the suffix of "
"``filename``."
msgstr ""

#: ../../export_results.rst:17
msgid "Taichi now supports saving to ``png``, ``jpg``, and ``bmp`` formats."
msgstr ""

#: ../../export_results.rst:18
msgid "We recommend using ``png`` format. For example:"
msgstr ""

#: ../../export_results.rst:20
msgid ""
"import taichi as ti\n"
"import os\n"
"\n"
"ti.init()\n"
"\n"
"pixels = ti.var(ti.u8, shape=(512, 512, 3))\n"
"\n"
"@ti.kernel\n"
"def paint():\n"
"    for i, j, k in pixels:\n"
"        pixels[i, j, k] = ti.random() * 255\n"
"\n"
"iterations = 1000\n"
"gui = ti.GUI(\"Random pixels\", res=512)\n"
"\n"
"# mainloop\n"
"for i in range(iterations):\n"
"    paint()\n"
"    gui.set_image(pixels)\n"
"\n"
"    filename = f'frame_{i:05d}.png'   # create filename with suffix png\n"
"    print(f'Frame {i} is recorded in {filename}')\n"
"    gui.show(filename)  # export and show in GUI"
msgstr ""

#: ../../export_results.rst:46
msgid ""
"After running the code above, you will get a series of images in the "
"current folder."
msgstr ""

#: ../../export_results.rst:49
msgid "Export images using ``ti.imwrite``"
msgstr ""

#: ../../export_results.rst:50
msgid ""
"To save images without invoking ``ti.GUI.show(filename)``, use "
"``ti.imwrite(filename)``. For example:"
msgstr ""

#: ../../export_results.rst:52
msgid ""
"import taichi as ti\n"
"\n"
"ti.init()\n"
"\n"
"pixels = ti.var(ti.u8, shape=(512, 512, 3))\n"
"\n"
"@ti.kernel\n"
"def set_pixels():\n"
"    for i, j, k in pixels:\n"
"        pixels[i, j, k] = ti.random() * 255\n"
"\n"
"set_pixels()\n"
"filename = f'imwrite_export.png'\n"
"ti.imwrite(pixels.to_numpy(), filename)\n"
"print(f'The image has been saved to {filename}')"
msgstr ""

#: ../../export_results.rst:70
msgid ""
"``ti.imwrite`` can export Taichi tensors (``ti.Matrix``, ``ti.Vector``, "
"``ti.var``) and numpy tensors ``np.ndarray``."
msgstr ""

#: ../../export_results.rst:71
msgid ""
"Same as above ``ti.GUI.show(filename)``, the image format (``png``, "
"``jpg`` and ``bmp``) is also controlled by the suffix of ``filename`` in "
"``ti.imwrite(filename)``."
msgstr ""

#: ../../export_results.rst:72
msgid ""
"Meanwhile, the resulted image type (grayscale, RGB, or RGBA) is "
"determined by **the number of channels in the input tensor**, i.e., the "
"length of the third dimension (``tensor.shape[2]``)."
msgstr ""

#: ../../export_results.rst:73
msgid ""
"In other words, a tensor that has shape ``(w, h)`` or ``(w, h, 1)`` will "
"be exported as a grayscale image."
msgstr ""

#: ../../export_results.rst:74
msgid ""
"If you want to export ``RGB`` or ``RGBA`` images instead, the input "
"tensor should have a shape ``(w, h, 3)`` or ``(w, h, 4)`` respectively."
msgstr ""

#: ../../export_results.rst:78
msgid ""
"All Taichi tensors have their own data types, such as ``ti.u8`` and "
"``ti.f32``. Different data types can lead to different behaviors of "
"``ti.imwrite``. Please check out :ref:`gui` for more details."
msgstr ""

#: ../../export_results.rst:80
msgid ""
"Taichi offers other helper functions that read and show images in "
"addition to ``ti.imwrite``. They are also demonstrated in :ref:`gui`."
msgstr ""

#: ../../export_results.rst:83
msgid "Export videos"
msgstr ""

#: ../../export_results.rst:87
msgid ""
"The video export utilities of Taichi depend on ``ffmpeg``. If ``ffmpeg`` "
"is not installed on your machine, please follow the installation "
"instructions of ``ffmpeg`` at the end of this page."
msgstr ""

#: ../../export_results.rst:89
msgid ""
"``ti.VideoManger`` can help you export results in ``mp4`` or ``gif`` "
"format. For example,"
msgstr ""

#: ../../export_results.rst:91
msgid ""
"import taichi as ti\n"
"\n"
"ti.init()\n"
"\n"
"pixels = ti.var(ti.u8, shape=(512, 512, 3))\n"
"\n"
"@ti.kernel\n"
"def paint():\n"
"    for i, j, k in pixels:\n"
"        pixels[i, j, k] = ti.random() * 255\n"
"\n"
"result_dir = \"./results\"\n"
"video_manger = ti.VideoManager(output_dir=result_dir, framerate=24, "
"automatic_build=False)\n"
"\n"
"for i in range(50):\n"
"    paint()\n"
"\n"
"    pixels_img = pixels.to_numpy()\n"
"    video_manger.write_frame(pixels_img)\n"
"    print(f'\\rFrame {i+1}/50 is recorded', end='')\n"
"\n"
"print()\n"
"print('Exporting .mp4 and .gif videos...')\n"
"video_manger.make_video(gif=True, mp4=True)\n"
"print(f'MP4 video is saved to "
"{video_manger.get_output_filename(\".mp4\")}')\n"
"print(f'GIF video is saved to "
"{video_manger.get_output_filename(\".gif\")}')"
msgstr ""

#: ../../export_results.rst:120
msgid ""
"After running the code above, you will find the output videos in the "
"``./results/`` folder."
msgstr ""

#: ../../export_results.rst:123
msgid "Install ffmpeg"
msgstr ""

#: ../../export_results.rst:126
msgid "Install ffmpeg on Windows"
msgstr ""

#: ../../export_results.rst:128
msgid ""
"Download the ``ffmpeg`` archive(named ``ffmpeg-2020xxx.zip``) from "
"`ffmpeg <https://ffmpeg.org/download.html>`_;"
msgstr ""

#: ../../export_results.rst:130
msgid "Unzip this archive to a folder, such as \"D:/YOUR_FFMPEG_FOLDER\";"
msgstr ""

#: ../../export_results.rst:132
msgid ""
"**Important:** add ``D:/YOUR_FFMPEG_FOLDER/bin`` to the ``PATH`` "
"environment variable;"
msgstr ""

#: ../../export_results.rst:134
msgid ""
"Open the Windows ``cmd`` or ``PowerShell`` and type the line of code "
"below to test your installation. If ``ffmpeg`` is set up properly, the "
"version information will be printed."
msgstr ""

#: ../../export_results.rst:136
msgid "ffmpeg -version"
msgstr ""

#: ../../export_results.rst:141
msgid "Install ``ffmpeg`` on Linux"
msgstr ""

#: ../../export_results.rst:142
msgid ""
"Most Linux distribution came with ``ffmpeg`` natively, so you do not need"
" to read this part if the ``ffmpeg`` command is already there on your "
"machine."
msgstr ""

#: ../../export_results.rst:143
msgid "Install ``ffmpeg`` on Ubuntu"
msgstr ""

#: ../../export_results.rst:145
msgid ""
"sudo apt-get update\n"
"sudo apt-get install ffmpeg"
msgstr ""

#: ../../export_results.rst:150
msgid "Install ``ffmpeg`` on CentOS and RHEL"
msgstr ""

#: ../../export_results.rst:152
msgid "sudo yum install ffmpeg ffmpeg-devel"
msgstr ""

#: ../../export_results.rst:156
msgid "Install ``ffmpeg`` on Arch Linux:"
msgstr ""

#: ../../export_results.rst:162
msgid "Test your installation using"
msgstr ""

#: ../../export_results.rst:164
msgid "ffmpeg -h"
msgstr ""

#: ../../export_results.rst:169
msgid "Install ``ffmpeg`` on OS X"
msgstr ""

#: ../../export_results.rst:171
msgid "``ffmpeg`` can be installed on OS X using ``homebrew``:"
msgstr ""

#: ../../export_results.rst:173
msgid "brew install ffmpeg"
msgstr ""

#: ../../export_results.rst:178
msgid "Export PLY files"
msgstr ""

#: ../../export_results.rst:179
msgid ""
"``ti.PLYwriter`` can help you export results in the ``ply`` format. Below"
" is a short example of exporting 10 frames of a moving cube with vertices"
" randomly colored,"
msgstr ""

#: ../../export_results.rst:181
msgid ""
"import taichi as ti\n"
"import numpy as np\n"
"\n"
"ti.init(arch=ti.cpu)\n"
"\n"
"num_vertices = 1000\n"
"pos = ti.Vector(3, dt=ti.f32, shape=(10, 10, 10))\n"
"rgba = ti.Vector(4, dt=ti.f32, shape=(10, 10, 10))\n"
"\n"
"\n"
"@ti.kernel\n"
"def place_pos():\n"
"    for i, j, k in pos:\n"
"        pos[i, j, k] = 0.1 * ti.Vector([i, j, k])\n"
"\n"
"\n"
"@ti.kernel\n"
"def move_particles():\n"
"    for i, j, k in pos:\n"
"        pos[i, j, k] += ti.Vector([0.1, 0.1, 0.1])\n"
"\n"
"\n"
"@ti.kernel\n"
"def fill_rgba():\n"
"    for i, j, k in rgba:\n"
"        rgba[i, j, k] = ti.Vector(\n"
"            [ti.random(), ti.random(), ti.random(), ti.random()])\n"
"\n"
"\n"
"place_pos()\n"
"series_prefix = \"example.ply\"\n"
"for frame in range(10):\n"
"    move_particles()\n"
"    fill_rgba()\n"
"    # now adding each channel only supports passing individual np.array\n"
"    # so converting into np.ndarray, reshape\n"
"    # remember to use a temp var to store so you dont have to convert "
"back\n"
"    np_pos = np.reshape(pos.to_numpy(), (num_vertices, 3))\n"
"    np_rgba = np.reshape(rgba.to_numpy(), (num_vertices, 4))\n"
"    # create a PLYWriter\n"
"    writer = ti.PLYWriter(num_vertices=num_vertices)\n"
"    writer.add_vertex_pos(np_pos[:, 0], np_pos[:, 1], np_pos[:, 2])\n"
"    writer.add_vertex_rgba(\n"
"        np_rgba[:, 0], np_rgba[:, 1], np_rgba[:, 2], np_rgba[:, 3])\n"
"    writer.export_frame_ascii(frame, series_prefix)"
msgstr ""

#: ../../export_results.rst:229
msgid ""
"After running the code above, you will find the output sequence of "
"``ply`` files in the current working directory. Next, we will break down "
"the usage of ``ti.PLYWriter`` into 4 steps and show some examples."
msgstr ""

#: ../../export_results.rst:231
msgid "Setup ``ti.PLYWriter``"
msgstr ""

#: ../../export_results.rst:233
msgid ""
"# num_vertices must be a positive int\n"
"# num_faces is optional, default to 0\n"
"# face_type can be either \"tri\" or \"quad\", default to \"tri\"\n"
"\n"
"# in our previous example, a writer with 1000 vertices and 0 triangle "
"faces is created\n"
"num_vertices = 1000\n"
"writer = ti.PLYWriter(num_vertices=num_vertices)\n"
"\n"
"# in the below example, a writer with 20 vertices and 5 quadrangle faces "
"is created\n"
"writer2 = ti.PLYWriter(num_vertices=20, num_faces=5, face_type=\"quad\")"
msgstr ""

#: ../../export_results.rst:246
msgid "Add required channels"
msgstr ""

#: ../../export_results.rst:248
msgid ""
"# A 2D grid with quad faces\n"
"#     y\n"
"#     |\n"
"# z---/\n"
"#    x\n"
"#         19---15---11---07---03\n"
"#         |    |    |    |    |\n"
"#         18---14---10---06---02\n"
"#         |    |    |    |    |\n"
"#         17---13---19---05---01\n"
"#         |    |    |    |    |\n"
"#         16---12---08---04---00\n"
"\n"
"writer = ti.PLYWriter(num_vertices=20, num_faces=12, face_type=\"quad\")\n"
"\n"
"# For the vertices, the only required channel is the position,\n"
"# which can be added by passing 3 np.array x, y, z into the following "
"function.\n"
"\n"
"x = np.zeros(20)\n"
"y = np.array(list(np.arange(0, 4))*5)\n"
"z = np.repeat(np.arange(5), 4)\n"
"writer.add_vertex_pos(x, y, z)\n"
"\n"
"# For faces (if any), the only required channel is the list of vertex "
"indices that each face contains.\n"
"indices = np.array([0, 1, 5, 4]*12)+np.repeat(\n"
"    np.array(list(np.arange(0, 3))*4)+4*np.repeat(np.arange(4), 3), 4)\n"
"writer.add_faces(indices)"
msgstr ""

#: ../../export_results.rst:278
msgid "Add optional channels"
msgstr ""

#: ../../export_results.rst:280
msgid ""
"# Add custome vertex channel, the input should include a key, a supported"
" datatype and, the data np.array\n"
"vdata = np.random.rand(20)\n"
"writer.add_vertex_channel(\"vdata1\", \"double\", vdata)\n"
"\n"
"# Add custome face channel\n"
"foo_data = np.zeros(12)\n"
"writer.add_face_channel(\"foo_key\", \"foo_data_type\", foo_data)\n"
"# error! because \"foo_data_type\" is not a supported datatype. Supported"
" ones are\n"
"# ['char', 'uchar', 'short', 'ushort', 'int', 'uint', 'float', 'double']\n"
"\n"
"# PLYwriter already defines several useful helper functions for common "
"channels\n"
"# Add vertex color, alpha, and rgba\n"
"# using float/double r g b alpha to reprent color, the range should be 0 "
"to 1\n"
"r = np.random.rand(20)\n"
"g = np.random.rand(20)\n"
"b = np.random.rand(20)\n"
"alpha = np.random.rand(20)\n"
"writer.add_vertex_color(r, g, b)\n"
"writer.add_vertex_alpha(alpha)\n"
"# equivilantly\n"
"# add_vertex_rgba(r, g, b, alpha)\n"
"\n"
"# vertex normal\n"
"writer.add_vertex_normal(np.ones(20), np.zeros(20), np.zeros(20))\n"
"\n"
"# vertex index, and piece (group id)\n"
"writer.add_vertex_id()\n"
"writer.add_vertex_piece(np.ones(20))\n"
"\n"
"# Add face index, and piece (group id)\n"
"# Indexing the existing faces in the writer and add this channel to face "
"channels\n"
"writer.add_face_id()\n"
"# Set all the faces is in group 1\n"
"writer.add_face_piece(np.ones(12))"
msgstr ""

#: ../../export_results.rst:317
msgid "Export files"
msgstr ""

#: ../../export_results.rst:319
msgid ""
"series_prefix = \"example.ply\"\n"
"series_prefix_ascii = \"example_ascii.ply\"\n"
"# Export a single file\n"
"# use ascii so you can read the content\n"
"writer.export_ascii(series_prefix_ascii)\n"
"\n"
"# alternatively, use binary for a bit better performance\n"
"# writer.export(series_prefix)\n"
"\n"
"# Export a sequence of files, ie in 10 frames\n"
"for frame in range(10):\n"
"    # write each frame as i.e. \"example_000000.ply\" in your current "
"running folder\n"
"    writer.export_frame_ascii(frame, series_prefix_ascii)\n"
"    # alternatively, use binary\n"
"    # writer.export_frame(frame, series_prefix)\n"
"\n"
"    # update location/color\n"
"    x = x + 0.1*np.random.rand(20)\n"
"    y = y + 0.1*np.random.rand(20)\n"
"    z = z + 0.1*np.random.rand(20)\n"
"    r = np.random.rand(20)\n"
"    g = np.random.rand(20)\n"
"    b = np.random.rand(20)\n"
"    alpha = np.random.rand(20)\n"
"    # re-fill\n"
"    writer = ti.PLYWriter(num_vertices=20, num_faces=12, "
"face_type=\"quad\")\n"
"    writer.add_vertex_pos(x, y, z)\n"
"    writer.add_faces(indices)\n"
"    writer.add_vertex_channel(\"vdata1\", \"double\", vdata)\n"
"    writer.add_vertex_color(r, g, b)\n"
"    writer.add_vertex_alpha(alpha)\n"
"    writer.add_vertex_normal(np.ones(20), np.zeros(20), np.zeros(20))\n"
"    writer.add_vertex_id()\n"
"    writer.add_vertex_piece(np.ones(20))\n"
"    writer.add_face_id()\n"
"    writer.add_face_piece(np.ones(12))"
msgstr ""

#: ../../export_results.rst:359
msgid "Import ``ply`` files into Houdini and Blender"
msgstr ""

#: ../../export_results.rst:360
msgid ""
"Houdini supports importing a series of ``ply`` files sharing the same "
"prefix/post-fix. Our ``export_frame`` can achieve the requirement for "
"you. In Houdini, click ``File->Import->Geometry`` and navigate to the "
"folder containing your frame results, who should be collapsed into one "
"single entry like ``example_$F6.ply (0-9)``. Double-click this entry to "
"finish the importing process."
msgstr ""

#: ../../export_results.rst:362
msgid ""
"Blender requires an add-on called `Stop-motion-OBJ "
"<https://github.com/neverhood311/Stop-motion-OBJ>`_ to load the result "
"sequences. A very detailed explanation `video "
"<https://www.youtube.com/watch?v=Ja7F7WHD39Q>`_ is provided by the author"
" on how to install, enable, and use the add-on. Just keep in mind that "
"significant changes in the workflow were made in their most recent test "
"releases. To follow their instruction readme and video, please use "
"``v2.0.2``."
msgstr ""

